#!/usr/bin/env bash
set -euo pipefail

# Custom Hosting Panel installer (Panel / Node / Both)
# - Asks for: panel name, role, http/https, (domain + email if https)
# - Writes .env (quoted values) and does NOT regenerate secrets if already present
# - Starts docker compose with the right profiles

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

ENV_FILE="$ROOT_DIR/.env"

bold() { printf "\033[1m%s\033[0m\n" "$*"; }
say()  { printf "%s\n" "$*"; }

need_root() {
  if [[ "${EUID:-$(id -u)}" -ne 0 ]]; then
    say "Please run as root (use sudo)"
    exit 1
  fi
}

# load existing .env if present (preserve secrets)
load_env_if_exists() {
  if [[ -f "$ENV_FILE" ]]; then
    # shellcheck disable=SC1090
    set -a; source "$ENV_FILE" 2>/dev/null || true; set +a
  fi
}

gen_secret() {
  # 32 bytes base64
  openssl rand -base64 32 2>/dev/null | tr -d '\n'
}

ensure_docker() {
  if command -v docker >/dev/null 2>&1; then
    say "Docker already installed."
    return
  fi

  say "Installing Docker..."
  apt-get update -y
  apt-get install -y ca-certificates curl gnupg lsb-release
  install -m 0755 -d /etc/apt/keyrings
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
  chmod a+r /etc/apt/keyrings/docker.gpg
  echo \
    "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
    $(. /etc/os-release && echo "$VERSION_CODENAME") stable" \
    > /etc/apt/sources.list.d/docker.list
  apt-get update -y
  apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
  systemctl enable --now docker
}

prompt_panel_name() {
  bold ""
  bold "Panel name"
  local yn
  read -r -p "Do you want to set a custom panel name? (y/n) " yn
  if [[ "${yn,,}" == "y" ]]; then
    read -r -p "Enter panel name: " PANEL_NAME_INPUT
  else
    PANEL_NAME_INPUT="Custom Hosting Panel"
  fi
}

prompt_role() {
  bold ""
  bold "Install role"
  read -r -p "Are you installing the PANEL, the NODE, or BOTH on this VPS? (panel/node/both) [both]: " ROLE_INPUT
  ROLE_INPUT="${ROLE_INPUT:-both}"
  ROLE_INPUT="${ROLE_INPUT,,}"
  if [[ "$ROLE_INPUT" != "panel" && "$ROLE_INPUT" != "node" && "$ROLE_INPUT" != "both" ]]; then
    say "Invalid choice: $ROLE_INPUT"
    exit 1
  fi
}

prompt_http_https() {
  bold ""
  bold "HTTP or HTTPS"
  read -r -p "Use HTTPS with a domain? (https/http) [http]: " PROTO_INPUT
  PROTO_INPUT="${PROTO_INPUT:-http}"
  PROTO_INPUT="${PROTO_INPUT,,}"
  if [[ "$PROTO_INPUT" != "http" && "$PROTO_INPUT" != "https" ]]; then
    say "Invalid choice: $PROTO_INPUT"
    exit 1
  fi

  DOMAIN_INPUT=""
  EMAIL_INPUT=""
  if [[ "$PROTO_INPUT" == "https" ]]; then
    read -r -p "Domain (example: panel.example.com): " DOMAIN_INPUT
    if [[ -z "$DOMAIN_INPUT" ]]; then
      say "Domain is required for https."
      exit 1
    fi
    read -r -p "Email for Let's Encrypt (used for expiry notices): " EMAIL_INPUT
    if [[ -z "$EMAIL_INPUT" ]]; then
      say "Email is required for https."
      exit 1
    fi
  fi
}

write_env() {
  load_env_if_exists

  # Preserve secrets if present
  JWT_SECRET_VALUE="${JWT_SECRET:-}"
  NODE_TOKEN_VALUE="${NODE_TOKEN:-}"

  if [[ -z "$JWT_SECRET_VALUE" ]]; then
    JWT_SECRET_VALUE="$(gen_secret)"
  fi
  if [[ -z "$NODE_TOKEN_VALUE" ]]; then
    NODE_TOKEN_VALUE="$(gen_secret)"
  fi

  # panel url
  if [[ "$PROTO_INPUT" == "https" ]]; then
    PANEL_PUBLIC_URL_VALUE="https://${DOMAIN_INPUT}"
  else
    PANEL_PUBLIC_URL_VALUE="http://localhost"
    # if we can detect public IP, set it (best-effort)
    PUBLIC_IP="$(curl -fsS https://api.ipify.org 2>/dev/null || true)"
    if [[ -n "$PUBLIC_IP" ]]; then
      PANEL_PUBLIC_URL_VALUE="http://${PUBLIC_IP}"
    fi
  fi

  cat > "$ENV_FILE" <<EOF
# Generated by scripts/install.sh
NEXT_PUBLIC_PANEL_NAME="${PANEL_NAME_INPUT}"
DOMAIN="${DOMAIN_INPUT}"
PANEL_PUBLIC_URL="${PANEL_PUBLIC_URL_VALUE}"
JWT_SECRET="${JWT_SECRET_VALUE}"
NODE_TOKEN="${NODE_TOKEN_VALUE}"
EOF

  # Make .env editable by the normal user
  if [[ -n "${SUDO_USER:-}" ]]; then
    chown "${SUDO_USER}:${SUDO_USER}" "$ENV_FILE" || true
  fi

  say ""
  bold "Saved .env"
  say " - PANEL_PUBLIC_URL: ${PANEL_PUBLIC_URL_VALUE}"
  say " - NODE_TOKEN: ${NODE_TOKEN_VALUE}"
  say "Keep NODE_TOKEN safe: you'll use it when adding the node in the admin page."
}

configure_nginx() {
  mkdir -p "$ROOT_DIR/nginx/conf.d"

  if [[ "$PROTO_INPUT" == "https" ]]; then
    say ""
    say "Configuring nginx for HTTPS..."

    # install certbot and get cert
    apt-get update -y
    apt-get install -y certbot

    # stop anything on :80 for standalone auth (best-effort)
    docker compose --profile panel --profile node down >/dev/null 2>&1 || true

    certbot certonly --standalone -d "$DOMAIN_INPUT" \
      --non-interactive --agree-tos -m "$EMAIL_INPUT" || {
        say "Certbot failed. You can re-run certbot manually then re-run this installer."
        exit 1
      }

    # render template
    DOMAIN="$DOMAIN_INPUT" envsubst < "$ROOT_DIR/nginx/conf.d/https.conf.template" > "$ROOT_DIR/nginx/conf.d/default.conf"

  else
    say ""
    say "Configuring nginx for HTTP..."
    cat "$ROOT_DIR/nginx/conf.d/http.conf.template" > "$ROOT_DIR/nginx/conf.d/default.conf"
  fi
}

start_services() {
  say ""
  case "$ROLE_INPUT" in
    panel)
      bold "Starting PANEL services..."
      docker compose --profile panel up -d --build
      ;;
    node)
      bold "Starting NODE services..."
      docker compose --profile node up -d --build
      ;;
    both)
      bold "Starting BOTH PANEL + NODE services..."
      docker compose --profile panel --profile node up -d --build
      ;;
  esac
}

main() {
  need_root
  ensure_docker
  prompt_panel_name
  prompt_role
  prompt_http_https
  write_env
  configure_nginx
  start_services

  say ""
  bold "Done!"
  if [[ "$PROTO_INPUT" == "https" ]]; then
    say "Open: https://${DOMAIN_INPUT}"
  else
    # Try to show public IP
    PUBLIC_IP="$(curl -fsS https://api.ipify.org 2>/dev/null || true)"
    if [[ -n "$PUBLIC_IP" ]]; then
      say "Open: http://${PUBLIC_IP}"
    else
      say "Open: http://<YOUR_SERVER_IP>"
    fi
  fi
}

main "$@"
